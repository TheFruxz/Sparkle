---
description: The commands, with some Sparkle
---

# ðŸ–¨ Interchanges

## What are Interchanges?

Interchanges can quite simply translate to commands with automation and systems hidden in the background, to ensure a good user experience.

They help to easily construct heavy and complicated structures without having to look at cluttered code or needing a master's degree in science and space engineering.

The interchanges help you concentrate on the important things of creating interchanges, but how? Let's look at an example:

```kotlin
class TestInterchange : Interchange(
   label = "test",
   aliases = setOf("mytest"),
   requiresApproval = true,
   requiredClient = InterchangeUserRestriction.ONLY_PLAYERS,
) {
   override val execution: suspend InterchangeAccess<out InterchangeExecutor>.() -> InterchangeResult = {
      
      executor.sendMessage("Hello World!")
      InterchangeResult.SUCCESS
      
   }
}
```

This is a simple Interchange, with simple and fully coded functionality. No input checks, just some background systematic, enough to be an easy-to-go solution.

You can see, that the execution property is the code block, which will be executed if the executor performs the command.

In the constructor, we can see some setup lines, which set the command name, aliases, and if the interchange execution requires permission. Some of these things are normally registered via the plugin.yml file, but Sparkle automatically registers the added interchanges into the runtime representation of this file, so you don't have to specify the commands in your plugin.yml

There are more properties available for classic Interchanges:

{% code title="Interchange.kt#constructor" lineNumbers="true" %}
```kotlin
final override val label: String, // The command name
val aliases: Set<String> = emptySet(), // The registered aliases
val requiresApproval: Boolean = false, // Does the execution requires a permission
val requiredClient: InterchangeUserRestriction = NOT_RESTRICTED, // only for players/console or both?
val cooldown: Duration = Duration.ZERO, // How long of an cooldown does the execution has for a player
val completion: InterchangeStructure<out InterchangeExecutor> = emptyInterchangeStructure(), // Tab-Completion setup
val ignoreInputValidation: Boolean = false, // Does the tab-completion setup checks, if the input is valid
val description: String = "An command, generated by sparkle!", // The command description
val permissionMessage: Component? = null, // The permissionMessage (will not be overwritten, if null)
var forcedApproval: Approval? = null, // A permission, another than the default auto-generated one (default: <app-identity>.interchange.<label>)
var forcedExecutionContext: CoroutineContext? = null, // A context, another than the default one
final override val preferredVendor: App? = null, // A app, another than the registering app
```
{% endcode %}

These are the properties, which can be modified. Some of them are nullable and by default null, which is 'modifiers'. This means, if they are null, the default-generated ones will be chosen. But if not null these will be used instead of the default ones.

Another thing that you will find, which is unknown, is the complete property. This is a whole new topic to talk about (visit [InterchangeStructure](interchangestructure.md)) because this is where the `fun` begins :smile:

<figure><img src="../.gitbook/assets/Anakin having Kotlin fun.png" alt="Anakin Skywalking talking about, that there is the reason, where the fun begins"><figcaption><p>fun, the keyword for starting a new function in Kotlin. Funny, because fun can also mean enjoying something. Especially because Kotlin is the most enjoyable programming Language in the World.</p></figcaption></figure>
